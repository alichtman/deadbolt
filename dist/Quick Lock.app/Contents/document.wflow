<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>444.42</string>
	<key>AMApplicationVersion</key>
	<string>2.9</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0.2</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>-- Quick Lock v1.4-- Easy File/Folder Encryption and Decryption with openssl-- Written by: Aaron Lichtman &lt;aaronlichtman@gmail.com&gt;-- Notes to anyone editing this script:-- Watch the quoting of paths. Unlike bash, AppleScript chokes on paths that are quoted more than once, so you can't just throw a pair of quotes around a path randomly.------------------------ Globals / Constants----------------------global encryptedExtensionglobal cdToRightDirglobal configFileset configFile to POSIX path of (path to home folder) &amp; ".quick-lock.plist"--------------------- Helper Functions--------------------- https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/ManipulateText.htmlon findAndReplaceInText(theText, theSearchString, theReplacementString)	set AppleScript's text item delimiters to theSearchString	set theTextItems to every text item of theText	set AppleScript's text item delimiters to theReplacementString	set theText to theTextItems as string	set AppleScript's text item delimiters to ""	return theTextend findAndReplaceInText-- TODO: Is this the proper way to do that?on userExit()	error number -128end userExiton readValueFromConfig(key)	tell application "System Events"		tell property list file configFile			return value of property list item key		end tell	end tellend readValueFromConfig-- Returns true if the path exists as either a file or directoryon checkIfFileExists(path)	try		do shell script cdToRightDir &amp; "test -e " &amp; path	on error		return false	end try	return trueend checkIfFileExistson removeFile(path)	log "Removing: " &amp; path	do shell script cdToRightDir &amp; "rm " &amp; pathend removeFileon decompressAndRemoveZip(filePath)	-- If it's a zip, auto decompress it and remove the zip	set decryptedFileType to getFileType(filePath)	log "Decrypted File Type: " &amp; decryptedFileType	if decryptedFileType starts with "Zip" then		do shell script cdToRightDir &amp; " unzip -u " &amp; filePath		removeFile(filePath)	end ifend decompressAndRemoveZip-- Removes zip archive if we created it and then exits. zipPath should be quoted already.on cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, zipPath)	log "Cleaning up and exiting."	if isEncryptingDirFlag and not zipAlreadyExistedFlag then		removeFile(zipPath)	end if	userExit()end cleanUpAndExit-- Returns the SHA1 sum of the filePath passed in. filePath should be quoted alreadyon hashFile(filePath)	set hashCommand to cdToRightDir &amp; "openssl sha1 " &amp; filePath &amp; " | rev | cut -d' ' -f1 | rev"	log "Hash command: $ " &amp; hashCommand	set hash to do shell script hashCommand	log "Hashing: " &amp; filePath &amp; " -&gt; " &amp; hash	return hashend hashFileon getFileType(escapedFilePath)	set fileType to do shell script "file " &amp; escapedFilePath &amp; " | sed 's/^.*: //'"	log "Detected fileType: " &amp; fileType	return fileTypeend getFileTypeon changeFileIcon(encryptedFileName)	set appPath to "/Applications/Quick\\ Lock.app/Contents/"	set pngIconFile to appPath &amp; "/Resources/EncryptedFileIcon.png"	log "PNG Icon File: " &amp; pngIconFile	set changeFileScript to appPath &amp; "/MacOS/set-custom-icon.sh"	log "Change File Script: " &amp; changeFileScript	set encryptedFileNameTrimmed to text 2 through -2 of encryptedFileName	log "Encrypted File Trimmed: " &amp; encryptedFileNameTrimmed	set changeFileIconCommand to cdToRightDir &amp; changeFileScript &amp; " " &amp; pngIconFile &amp; " " &amp; encryptedFileNameTrimmed	log "Change File Icon Command: $ " &amp; changeFileIconCommand	do shell script changeFileIconCommandend changeFileIcon-- Prompt for passphrase, enter it and verify decryption. If it's a ZIP, auto-extract and delete ZIP.on decryptFile(encryptedFilePath)	log "Decrypting: " &amp; encryptedFilePath	set decryptionKey to the text returned of (display dialog "Enter a decryption password:" default answer "")		-- Extract file hash from filename for decryption success verification	set originalHash to do shell script "echo " &amp; encryptedFilePath &amp; " | rev | cut -d'.' -f 2 | rev"	log "Original Hash: " &amp; originalHash	set unencryptedFilePath to quoted form of findAndReplaceInText(encryptedFilePath, "." &amp; originalHash &amp; encryptedExtension, "")	log "Unencryoted FilePath: " &amp; unencryptedFilePath	-- Decrypt the file	set quotedEncryptedFilePath to quoted form of encryptedFilePath	log "Decryption Command: $ openssl enc -d -aes-256-ctr -salt -in " &amp; quotedEncryptedFilePath &amp; " -out " &amp; unencryptedFilePath &amp; " -pass pass:" &amp; decryptionKey	do shell script "openssl enc -d -aes-256-ctr -salt -in " &amp; quotedEncryptedFilePath &amp; " -out " &amp; unencryptedFilePath &amp; " -pass pass:" &amp; decryptionKey		-- Detect decryption failures by comparing the checksums	set newHash to hashFile(unencryptedFilePath)	if newHash is not equal to originalHash then		log "Potential decryption error. Original hash (" &amp; originalHash &amp; ") does not match New Hash (" &amp; newHash &amp; ")"		-- Prompt to see if they want to continue when a hash-mismatch is detected.		-- The only time this should be continued through is when decrypting a file without a hash.		set potentialErrorPrompt to (display dialog "Potential decryption error. If the file you are trying to decrypt is missing a SHA1 hash, click 'Continue'. Otherwise, click 'Abort'" buttons {"Abort", "Continue"} default button "Continue")		if button returned of potentialErrorPrompt = "Abort" then			log "Aborting decryption."			removeFile(unencryptedFilePath)			userExit()		end if	else		log "Successful decryption!"		display dialog "Successful decryption!"				-- If the option to remove encrypted files after decrypting is set, remove the file		if readValueFromConfig("deleteEncryptedFileAfterDecryption") is equal to true then			log "Removing encrypted file after successful decryption."			removeFile(quotedEncryptedFilePath)		else			log "Not removing encrypted file after successful decryption."		end if	end if		decompressAndRemoveZip(unencryptedFilePath)end decryptFileon encryptFile(filePath, parentDir)	set fileToBeEncrypted to filePath	set zipAlreadyExistedFlag to false	set isEncryptingDirFlag to false		-- If the filePath is a folder, compress it into a zip file.	if kind of (info for filePath) is "folder" then		set isEncryptingDirFlag to true		log "Encrypting Directory."		set dirToBeZipped to findAndReplaceInText(text 1 through -2 of filePath, parentDir &amp; "/", "")		log "DirToBeZipped: " &amp; dirToBeZipped		log "Created: " &amp; fileToBeEncrypted		set fileToBeEncrypted to dirToBeZipped &amp; ".zip"		set quotedFileToBeEncrypted to quoted form of fileToBeEncrypted		set zipAlreadyExistedFlag to checkIfFileExists(quotedFileToBeEncrypted)		set zipCommand to cdToRightDir &amp; "zip -r " &amp; quotedFileToBeEncrypted &amp; " " &amp; quoted form of (dirToBeZipped &amp; "/")		log "Zip Command: $ " &amp; zipCommand		do shell script zipCommand	else		set quotedFileToBeEncrypted to quoted form of filePath	end if		-- Remove ZIP if user exits at either of these prompts	set encryptionKeyPrompt to (display dialog "Enter an encryption password for file: " &amp; fileToBeEncrypted buttons {"Cancel Encryption", "Ok"} default answer "" default button "Ok")	if button returned of encryptionKeyPrompt = "Cancel Encryption" then		log "Aborting encryption at first password prompt."		cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)	end if		set encryptionKeyConfirmationPrompt to (display dialog "Confirm the password: " &amp; fileToBeEncrypted buttons {"Cancel Encryption", "Ok"} default answer "" default button "Ok")	if button returned of encryptionKeyConfirmationPrompt = "Cancel Encryption" then		log "Aborting encryption at second password prompt."		cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)	end if		-- Validate the encryption key the user has provided to make sure there aren't any typos.	set encryptionKey to the text returned of encryptionKeyPrompt	if encryptionKey is not equal to the text returned of encryptionKeyConfirmationPrompt then		display dialog "ERROR: Encryption passwords did not match."		log "ERROR: Passwords didn't match"		userExit()	end if		set encryptedFileName to quoted form of (fileToBeEncrypted &amp; "." &amp; hashFile(quoted form of fileToBeEncrypted) &amp; encryptedExtension)	log "Encryption Command: $ openssl enc -aes-256-ctr -salt -in " &amp; quotedFileToBeEncrypted &amp; " -out " &amp; encryptedFileName &amp; " -pass pass:" &amp; encryptionKey	do shell script cdToRightDir &amp; "openssl enc -aes-256-ctr -salt -in " &amp; quotedFileToBeEncrypted &amp; " -out " &amp; encryptedFileName &amp; " -pass pass:" &amp; encryptionKey		changeFileIcon(encryptedFileName)	cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)end encryptFile--------- Main-------set encryptedExtension to readValueFromConfig("encryptedFileExtension")tell application "Finder" to set selected_items to selectionrepeat with itemRef in selected_items		-- Get filePath and escape it	set filePath to POSIX path of (itemRef as string)	set quotedAndEscapedPath to quoted form of filePath	log "FilePath: " &amp; filePath		-- Set up cdToRightDir command	set parentDir to do shell script "dirname " &amp; quotedAndEscapedPath	log "ParentDir: " &amp; parentDir	set cdToRightDir to "cd " &amp; quoted form of (parentDir) &amp; " &amp;&amp; "		-- Use filetype to figure out if we need to encrypt or decrypt it.	if getFileType(quotedAndEscapedPath) is equal to "openssl enc'd data with salted password" then		decryptFile(filePath)	else		encryptFile(filePath, parentDir)	end ifend repeat</string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0.2</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>InputUUID</key>
				<string>128A615A-9142-40A4-97A2-ED1B7FEECDE3</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>CB06710A-AE2C-4EEA-8CFA-84B1EDA971E7</string>
				<key>ShowWhenRun</key>
				<false/>
				<key>UUID</key>
				<string>9A1A5A9F-F633-45D3-AE8C-DB1CABA4AC11</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>505.250000:315.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
	</array>
	<key>connectors</key>
	<dict/>
	<key>workflowMetaData</key>
	<dict>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.application</string>
	</dict>
</dict>
</plist>
