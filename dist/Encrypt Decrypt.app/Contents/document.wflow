<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>444.42</string>
	<key>AMApplicationVersion</key>
	<string>2.9</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0.2</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>-- Easy File/Folder Encryption and Decryption with openssl-- Written by: Aaron Lichtman &lt;aaronlichtman@gmail.com&gt;-- Warnings to anyone editing this script:-- Watch those quoted paths. AppleScript chokes on paths that are quoted more than once... bash ftw (now that's a sentence I never thought I'd say...)-- This is some absolute shit code. I'm sorry. It works well, though.------------------------ Globals / Constants----------------------global configFileset configFile to POSIX path of (path to home folder) &amp; ".encrypt-decrypt.plist"global encryptedExtensionglobal missingOpenSSLErrorset missingOpenSSLError to "Error: openssl can't be found on your system. Make sure it's installed and on your $PATH."global cdToRightDir--------------------- Helper Functions--------------------- https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/ManipulateText.htmlon findAndReplaceInText(theText, theSearchString, theReplacementString)	set AppleScript's text item delimiters to theSearchString	set theTextItems to every text item of theText	set AppleScript's text item delimiters to theReplacementString	set theText to theTextItems as string	set AppleScript's text item delimiters to ""	return theTextend findAndReplaceInTexton userExit()	error number -128end userExiton readValueFromConfig(key)	tell application "System Events"		tell property list file configFile			return value of property list item key		end tell	end tellend readValueFromConfig-- Returns true if the path exists as either a file or directoryon checkIfFileExists(path)	try		do shell script cdToRightDir &amp; "test -e " &amp; path	on error		return false	end try	return trueend checkIfFileExistson removeFile(path)	log "Removing: " &amp; path	do shell script cdToRightDir &amp; "rm " &amp; pathend removeFile-- Removes zip archive if we created it and then exits. zipPath should be quoted already.on cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, zipPath)	log "Cleaning up and exiting."	if isEncryptingDirFlag and not zipAlreadyExistedFlag then		removeFile(zipPath)	end if	userExit()end cleanUpAndExit-- Returns the SHA1 sum of the filePath passed in. filePath should be quoted alreadyon hashFile(filePath)	set hashCommand to cdToRightDir &amp; "openssl sha1 " &amp; filePath &amp; " | rev | cut -d' ' -f1 | rev"	log "Hash command: " &amp; hashCommand	set hash to do shell script hashCommand	log "Hashing: " &amp; filePath &amp; " -&gt; " &amp; hash	return hashend hashFileon getFileType(escapedFilePath)	return do shell script "file " &amp; escapedFilePath &amp; " | sed 's/^.*: //'"end getFileType-- Prompt for passphrase, enter it and verify decryption. If it's a ZIP, auto-extract and delete ZIP.on decryptFile(filePath)	log "Decrypting: " &amp; filePath	set decryptionKey to the text returned of (display dialog "Enter a decryption password:" default answer "")		-- Extract file hash from filename for decryption success verification	set originalHash to do shell script "echo " &amp; filePath &amp; " | rev | cut -d'.' -f 2 | rev"	log "Original Hash: " &amp; originalHash	set unencryptedFilePath to quoted form of findAndReplaceInText(filePath, "." &amp; originalHash &amp; encryptedExtension, "")	log "Unencryoted FilePath: " &amp; unencryptedFilePath	-- Decrypt the file	log "openssl enc -d -aes-256-ctr -salt -in " &amp; quoted form of filePath &amp; " -out " &amp; unencryptedFilePath &amp; " -pass pass:" &amp; decryptionKey	do shell script "openssl enc -d -aes-256-ctr -salt -in " &amp; quoted form of filePath &amp; " -out " &amp; unencryptedFilePath &amp; " -pass pass:" &amp; decryptionKey		-- Detect decryption failures by comparing the checksums	if hashFile(unencryptedFilePath) is not equal to originalHash then		log "ERROR: Decryption failure for file: " &amp; filePath		display dialog "ERROR: Decryption failure for file: " &amp; filePath		do shell script cdToRightDir &amp; "rm " &amp; unencryptedFilePath		return	else		log "Successful decryption!"		display dialog "Successful decryption!"				-- If the option to remove encrypted files after decrypting is set, remove the file		if readValueFromConfig("deleteEncryptedFileAfterDecryption") is equal to true then			log "Removing encrypted file after successful decryption."			removeFile(quoted form of filePath)		else			log "Not removing encrypted file after successful decryption."		end if				-- If it's a zip, auto decompress it and remove the zip		set decryptedFileType to getFileType(unencryptedFilePath)		log "Decrypted File Type: " &amp; decryptedFileType		if decryptedFileType starts with "Zip" then			do shell script cdToRightDir &amp; " unzip -u " &amp; unencryptedFilePath			removeFile(unencryptedFilePath)		end if	end if	end decryptFileon encryptFile(filePath, parentDir)	set fileToBeEncrypted to filePath	set zipAlreadyExistedFlag to false	set isEncryptingDirFlag to false		-- If the filePath is a folder, compress it into a zip file.	if kind of (info for filePath) is "folder" then		set isEncryptingDirFlag to true		log "Encrypting Directory."		set dirToBeZipped to findAndReplaceInText(text 1 through -2 of filePath, parentDir &amp; "/", "")		log "DirToBeZipped: " &amp; dirToBeZipped		log "Created: " &amp; fileToBeEncrypted		set fileToBeEncrypted to dirToBeZipped &amp; ".zip"		set quotedFileToBeEncrypted to quoted form of fileToBeEncrypted		set zipAlreadyExistedFlag to checkIfFileExists(quotedFileToBeEncrypted)		set zipCommand to cdToRightDir &amp; "zip -r " &amp; quotedFileToBeEncrypted &amp; " " &amp; quoted form of (dirToBeZipped &amp; "/")		log "Zip Command: " &amp; zipCommand		do shell script zipCommand	else		set quotedFileToBeEncrypted to quoted form of filePath	end if		-- Remove ZIP if user exits at either of these prompts	set encryptionKeyPrompt to (display dialog "Enter an encryption password for file: " &amp; fileToBeEncrypted buttons {"Cancel Encryption", "Ok"} default answer "" default button "Ok")	if button returned of encryptionKeyPrompt = "Cancel Encryption" then		log "Aborting encryption."		cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)	end if		set encryptionKey to the text returned of encryptionKeyPrompt		set encryptionKeyConfirmationPrompt to (display dialog "Confirm the password: " &amp; fileToBeEncrypted buttons {"Cancel Encryption", "Ok"} default answer "" default button "Ok")	if button returned of encryptionKeyConfirmationPrompt = "Cancel Encryption" then		log "Aborting encryption."		cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)	end if		-- Validate the encryption key the user has provided to make sure there aren't any typos.	if encryptionKey is not equal to the text returned of encryptionKeyConfirmationPrompt then		display dialog "ERROR: Encryption passwords did not match."		log "ERROR: Passwords didn't match"		userExit()	end if		set encryptedFileName to quoted form of (fileToBeEncrypted &amp; "." &amp; hashFile(quoted form of fileToBeEncrypted) &amp; encryptedExtension)	log "Encrypted file to be created: " &amp; encryptedFileName	log "Encryption Command: openssl enc -aes-256-ctr -salt -in " &amp; quotedFileToBeEncrypted &amp; " -out " &amp; encryptedFileName &amp; " -pass pass:" &amp; encryptionKey	do shell script cdToRightDir &amp; "openssl enc -aes-256-ctr -salt -in " &amp; quotedFileToBeEncrypted &amp; " -out " &amp; encryptedFileName &amp; " -pass pass:" &amp; encryptionKey	cleanUpAndExit(isEncryptingDirFlag, zipAlreadyExistedFlag, quotedFileToBeEncrypted)end encryptFile--------- Main-------set encryptedExtension to readValueFromConfig("encryptedFileExtension")tell application "Finder" to set selected_items to selectionrepeat with itemRef in selected_items		-- Get filePath and escape it	set filePath to POSIX path of (itemRef as string)	set quotedAndEscapedPath to quoted form of filePath	log "FilePath: " &amp; filePath		-- Set up cdToRightDir command	set parentDir to do shell script "dirname " &amp; quotedAndEscapedPath	log "ParentDir: " &amp; parentDir	set cdToRightDir to "cd " &amp; quoted form of (parentDir) &amp; " &amp;&amp; "		-- Use filetype to figure out if we need to encrypt or decrypt it.	set fileType to getFileType(quotedAndEscapedPath)	log "Filetype: " &amp; fileType		-- If file is already encrypted, decrypt it.	if fileType is equal to "openssl enc'd data with salted password" then		decryptFile(filePath)	else		-- If it's not already encrypted, encrypt it.		encryptFile(filePath, parentDir)	end ifend repeat</string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0.2</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>InputUUID</key>
				<string>128A615A-9142-40A4-97A2-ED1B7FEECDE3</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>CB06710A-AE2C-4EEA-8CFA-84B1EDA971E7</string>
				<key>ShowWhenRun</key>
				<false/>
				<key>UUID</key>
				<string>9A1A5A9F-F633-45D3-AE8C-DB1CABA4AC11</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>505.250000:315.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
	</array>
	<key>connectors</key>
	<dict/>
	<key>workflowMetaData</key>
	<dict>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.application</string>
	</dict>
</dict>
</plist>
